<!DOCTYPE html>
<html>
  <head>
    <title>IdleOn optimizer</title>
    <style type="text/css">
      body {
        
      }

      table.cogboard {
      }

      table.cogboard tr > td {
        position: relative;
        display: inline-block;
        height: 38px;
        width: 38px;
        max-width: 38px;

        margin: 0 7px 6px 0;
        border: 1px solid black;
        border-bottom-width: 2px;

        background-image: url("cog_bg.png");
        background-size: contain;
      }
	  
	  .toMove:after {
        position: absolute;
        content: '';
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(27, 255, 0, 1);
        opacity: 0.2;
      }

      .result {
        display: flex;
        flex-direction: row;
        background: url("wooden.png");
      }

      .info {
        background: url("wooden_light.png") top;
        padding: 1em 0 0 1em;
      }

      #currentBoard {
        padding: 1em 0 0 1em;
      }

      .border {
        background: url("wooden_border.png") top right repeat-y;
        width: 30px;
      }

      .stats > .buildrate {
        color: silver;
      }

    .stats > .xpbonus {
      color: gold;
    }

    .stats > .flaggyrate {
      color: red;
    }

      @media (prefers-color-scheme: dark) {
        body {
          color: #eee;
          background: #121212;
        }
      }
    </style>
  </head>
  <body style="display: flex;flex-direction: column;max-height: 98vh;">
    <textarea type="textarea" id="input" rows="10" cols="100"></textarea>
    <button id="fetch" style="max-width: 15ch;">Fetch</button>
    <button id="load" style="max-width: 15ch;">Load</button>
    <p>
      <label for="flaggyShop">Gem Shop Flaggy upgrades</label>
      <input type="number" id="flaggyShop" value="0" style="width:6ch" disabled=true></input>
    </p>
    <p>
      <label for="buildRate">Build rate score weight</label>
      <input type="number" id="buildRate" value="2" style="width:6ch"></input>
    </p>
    <p>
      <label for="expBonus">EXP Bonus score weight</label>
      <input type="number" id="expBonus" value="50" style="width:6ch"></input>
    </p>
    <p>
      <label for="flaggy">Flaggy rate score weight</label>
      <input type="number" id="flaggy" value="5" style="width:6ch"></input>
    </p>
    <p>
      <label for="solveTime">Solve times (ms)</label>
      <input type="number" id="solveTime" value="1000" style="width:10ch"></input>
    </p>
    <button id="solve" style="max-width: 15ch;">Solve</button>
    <div class="result">
      <div class="info">
        <table class="cogboard">
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </table>
        <div class="stats">
          <span class="buildrate">
            <h3>Total Build Rate</h3>
            <p id="buildrate"></p>
          </span>
          <span class="xpbonus">
            <h3>Player XP Bonus</h3>
            <p id="xpbonus"></p>
          </span>
          <span class="flaggyrate">
            <h3>Flaggy Rate</h3>
            <p id="flaggyrate"></p>
          </span>
        </div>
      </div>
      <div class="border"></div>
      <div id="currentBoard"></div>
      <div id="steps" style="overflow: auto;min-height: 100px;max-height: 410px;"></div>
    </div>
    <p id="start"></p>
    <p id="end"></p>
    <script type="text/javascript">
      const ROWS = 8;
      const COLUMNS = 12;
      const OPTIMIZABLE = ["buildRate", "expBonus", "flaggy"];
	  const ICON_QUALITY_MAP = {
        ["0"]: "Nooby",
        ["1"]: "Decent",
        ["2"]: "Superb",
        ["3"]: "Ultimate",
        ["Y"]: "Yang",
        ["Z"]: "Yin"
	  };
      const ICON_TYPE_MAP = {
        ["A00"]: "Cog",
        ["A0"]: "CogB",
        ["A1"]: "Average",
        ["A2"]: "Spur",
        ["A2"]: "Stacked",
        ["A2"]: "Deckered",
        ["B0"]: "Double",
        ["B1"]: "Trips",
        ["B2"]: "Trabble",
        ["B3"]: "Quad",
        ["B3"]: "Penta",
        ["ad"]: "Adjacent",
        ["di"]: "Diagonal",
        ["up"]: "Up",
        ["do"]: "Down",
        ["le"]: "Left",
        ["ri"]: "Right",
        ["ro"]: "Row",
        ["co"]: "Column",
        ["cr"]: "Corner",
      };
	  const YIN_MAP = {
        ["A00"]: "Yin_Top_Left_Cog",
        ["A01"]: "Yin_Top_Right_Cog",
        ["A02"]: "Yin_Bottom_Left_Cog",
        ["A03"]: "Yin_Bottom_Right_Cog"
	  };
      
      const getInput = (id) => Number.parseInt(document.getElementById(id).value);
      const getFlaggyShop = getInput.bind(null, "flaggyShop");

      const cogBlank = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpUWrDnYQcchQO1koKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIo5OToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eKKBqlpGKx8RsblX0vaIffgwiirDETD2RXsyg6/i6h4evdxGe1f3cn2NAyZsM8IjEc0w3LOIN4plNS+e8TxxkJUkhPieeMOiCxI9cl11+41x0WOCZQSOTmicOEovFDpY7mJUMlXiaOKSoGuULWZcVzluc1UqNte7JXxjIaytprtMcQxxLSCAJETJqKKMCCxFaNVJMpGg/1sU/6viT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMCMaD3xbY/xgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rYWOgKFt4OK6rcl7wOUOMPKkS4bkSF6aQqEAvJ/RN+WA4Vugb83trbWP0wcgQ10t3wAHh0C4SNnrXd7t7+zt3zOt/n4AuHlyw22PBoIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfmCwgOMhatl4frAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAARNJREFUWMPtmM0KgzAMxzMJgiAivsQeZI+y9xdRURBhO+wwKWmSxh56SI7a/vPLh2nx8X49P1CgIQDA0NVFQY3zARUUag5m6jFNzS12p3cxNwylYQFEDkgjqAkgXKPRRU6AchqKck5i0JrgMXQiZUADG3tO7R3ng9yPlFhqf8XWa7NLZRAlQQkyx6khZowilyCt4Ny+ad3/YFLjD12dpczXgDktnNY9eSbdmXFUVSi96o5wjgEc+yqLOCuzZMyvPQ7GzCxqMqBFqG+bpPWcxbQwVTgU0s5BLRALJsFYgaSgru9Rcta3jTkrqTrXNqlCqFylsmZ4WndYthNw2U4A2LOD+BxzMAdzMAdzMMPfnt+xVJZ9ATWPsYm30CgcAAAAAElFTkSuQmCC";
      const cogBg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpUWrDnYQcchQO1koKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIo5OToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eKKBqlpGKx8RsblX0vaIffgwiirDETD2RXsyg6/i6h4evdxGe1f3cn2NAyZsM8IjEc0w3LOIN4plNS+e8TxxkJUkhPieeMOiCxI9cl11+41x0WOCZQSOTmicOEovFDpY7mJUMlXiaOKSoGuULWZcVzluc1UqNte7JXxjIaytprtMcQxxLSCAJETJqKKMCCxFaNVJMpGg/1sU/6viT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMCMaD3xbY/xgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rYWOgKFt4OK6rcl7wOUOMPKkS4bkSF6aQqEAvJ/RN+WA4Vugb83trbWP0wcgQ10t3wAHh0C4SNnrXd7t7+zt3zOt/n4AuHlyw22PBoIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfmCwgOOyi9NCEJAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAVRJREFUWMPtmDEKwjAUhp/liS09gFcoODg6eYFunsClZ/ASXsFLuHgBvYLg2FXcCmJLBR3EEmOal6TBRsibSpr8/5f3khAyWC9nD3AwEABgszsBAECWJs33r4P1ztIEAnA08E3oQrAcH6XsM1iGLE1eYFSMwqGRWVXW3UppE0akYQKIMiAVQZUJ8H1UdFEmIDLlRWUmbdAqk0fehMqACmxbu2jsKBwKx6NITHd9tfVXza4og0gJUpBddp5MAylyCtIUnBqHqgu/KmsrZWYnLNNC3S1vAkdVRaQXdBG2cQC37UonbhdWMvar8GB/BxZHCHH0fc7jpSi1ha63u1Z/WYi0LkVJXxR5YV6IMtYBIi+KFIwpEDUp9j+qmJlmRVeHXSaBbXNb8IFLUP4c82AezIOZvl3MJ+OmYX889wLCMjQZ2x5y2B7y3rPEcjhbysFqMXXycfgJ3ImUN+Kk6UcAAAAASUVORK5CYII=";

      const createElem = function createElem(tagName, style=undefined) {
        const elem = document.createElement(tagName);
        if (style) {
          elem.style = style;
        }
        return elem;
      }

      Cog = function (initialValues = {}) {
        return {
          _key: initialValues.key,
          get key() { return this._key },
          set key(v) { this._position = null; this._key = v },
          icon: initialValues.icon,
          initialKey: initialValues.initialKey,
          buildRate: initialValues.buildRate,
          isPlayer: initialValues.isPlayer,
          expGain: initialValues.expGain,
          flaggy: initialValues.flaggy,
          expBonus: initialValues.expBonus,
          buildRadiusBoost: initialValues.buildRadiusBoost,
          expRadiusBoost: initialValues.expRadiusBoost,
          flaggyRadiusBoost: initialValues.flaggyRadiusBoost,
          boostRadius: initialValues.boostRadius,
          fixed: initialValues.fixed,
          blocked: initialValues.blocked,
          _position: null,
          position(keyNum) {
            if (this._position && !keyNum) return this._position;
            keyNum = keyNum || Number.parseInt(this.key);
            const location = keyNum >= 96 ? keyNum <= 107 ? "build" : "spare" : "board";
            let perRow = 3;
            let offset = 108;
            if (location === "board") {
              perRow = 12;
              offset = 0;
            } else if (location === "build") {
              offset = 96;
            }
            const y = Math.floor((keyNum - offset) / perRow);
            const x = Math.floor((keyNum - offset) % perRow);
            return this._position = { location, x, y };
          }
        };
      }
      
      window.g = {
        cogs: {},
        board: [],
        best: null
      };
      window.f = {};
      
      f.verifyBoardIntegrity = (board) => {
        for (let y = 0; y < board.length; y++) {
          for (let x = 0; x < board[y].length; x++) {
            if (board[y][x].blocked) continue;
            const tempPos = board[y][x].position();
            if (tempPos.x !== x || tempPos.y !== y) {
              debugger;
            }
          }
        }
      }
      
      f.getScore = (board) => {
        const result = {
          buildRate: 0,
          expBonus: 0,
          flaggy: 0
        };
        const bonusGrid = Array(ROWS).fill(0).map(() => { return Array(COLUMNS).fill(0).map(() => { return { ...result } })});
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            const boosted = [];
            switch (entry.boostRadius) {
              case "diagonal":
                boosted.push([i-1, j-1],[i-1, j+1],[i+1, j-1],[i+1, j+1]);
                break;
              case "adjacent":
                boosted.push([i-1, j],[i, j+1],[i+1, j],[i, j-1]);
                break;
              case "up":
                boosted.push([i-2, j-1],[i-2, j],[i-2, j+1],[i-1, j-1],[i-1, j],[i-1, j+1]);
                break;
              case "right":
                boosted.push([i-1, j+2],[i, j+2],[i+1, j+2],[i-1, j+1],[i, j+1],[i+1, j+1]);
                break;
              case "down":
                boosted.push([i+2, j-1],[i+2, j],[i+2, j+1],[i+1, j-1],[i+1, j],[i+1, j+1]);
                break;
              case "left":
                boosted.push([i-1, j-2],[i, j-2],[i+1, j-2],[i-1, j-1],[i, j-1],[i+1, j-1]);
                break;
              case "row":
                for (let k = 0; k < COLUMNS; k++) {
                  if(j == k) continue;
                  boosted.push([i, k]);
                }
                break;
              case "column":
                for (let k = 0; k < ROWS; k++) {
                  if(i == k) continue;
                  boosted.push([k, j]);
                }
                break;
              case "corner":
                boosted.push([i-2, j-2],[i-2, j+2],[i+2, j-2],[i+2, j+2]);
                break;
              case "around":
                boosted.push([i-2, j],[i-1, j-1],[i-1, j],[i-1, j+1],[i, j-2],[i, j-1],[i, j+1],[i, j+2],[i+1, j-1],[i+1, j],[i+1, j+1],[i+2, j]);
                break;
              case "excogia":
                for (let k = 0; k < ROWS; k++) {
                  for (let l = 0; l < COLUMNS; l++) {
                    if(i === k && j === l) continue;
                    boosted.push([k, l]);
                  }
                }
                break;
              default:
                break;
            }
            for (const boostCord of boosted) {
              const bonus = saveGet(bonusGrid, ...boostCord);
              if (!bonus) continue;
              bonus.buildRate += entry.buildRadiusBoost  || 0;
              bonus.expBonus  += entry.expRadiusBoost    || 0;
              bonus.flaggy    += entry.flaggyRadiusBoost || 0;
            }
          }
        }
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            result.buildRate += entry.buildRate || 0;
            result.expBonus += entry.expBonus || 0;
            result.flaggy += entry.flaggy || 0;
            const bonus = bonusGrid[i][j];
            if (!bonus) continue;
            const b = (bonus.buildRate || 0) / 100;
            result.buildRate += Math.ceil((entry.buildRate || 0) * b);
            const e = (bonus.expBonus || 0) / 100;
            result.expBonus += Math.ceil((entry.expBonus || 0) * e);
            const f = (bonus.flaggy || 0) / 100;
            result.flaggy += Math.ceil((entry.flaggy || 0) * f);
          }
        }
        result.flaggy = Math.floor(result.flaggy * (1 + getFlaggyShop() * 0.5));
        return result;
      }
      
      f.getScoreSum = (score) => {
        let res = 0;
        for (const opt of OPTIMIZABLE) {
          res += score[opt] * getInput(opt);
        }
        return res;
      }
	  
	  f.printMove = (board, cog1, cog2, pos1, pos2) => {
        const toAdd = createElem("p", "color: white");
        toAdd.innerText = `Switch ${pos1.location}[${pos1.x + 1}|${pos1.y + 1}] (${cog1.buildRate || 0}:${cog1.expBonus || 0}:${cog1.flaggy || 0}) with ${pos2.location}[${pos2.x + 1}|${pos2.y + 1}] (${cog2.buildRate || 0}:${cog2.expBonus || 0}:${cog2.flaggy || 0})`;
        toAdd.onclick = () => f.printBoard(board, pos1, pos2);
        steps.appendChild(toAdd);
      }
      
      f.printBoard = (board, cord1={},cord2={}) => {
        const table = createElem("table");
        table.className = "cogboard";

        for (let i = 0; i < board.length; i++) {
          const row = createElem("tr");
          
          for (let j = 0; j < board[i].length; j++) {
            const col = createElem("td");
            
            const cog = board[i][j];
            let border = "black";
			let cssClass = "";
            if (cog.blocked) {
              // border = "red";
            } else if (cog.fixed) {
              border = "yellow";
            } else if ((cord1.location === "board" && i === cord1.y && j === cord1.x) || (cord2.location === "board" && i === cord2.y && j === cord2.x)) {
              border = "lightgreen";
			  cssClass = "toMove";
            }

            // TODO: Move to css
            col.style.border = `1px solid ${border}`;
            col.style.borderBottom = `2px solid ${border}`;
            col.style.backgroundImage = `url("${(!cog.blocked && cogBg) || cogBlank}")`;
            col.style.backgroundPosition = "center";
            col.style.backgroundSize = "cover";
			if (cssClass) {
			  col.classList.add(cssClass);
			}

            if (!cog.blocked) {
              const div = createElem("div");
              div.style.height = "100%";
			  if (cog.icon === "Blank") {
			    div.style.backgroundImage = `url("${cogBlank}")`;
			  } else if (cog.icon.startsWith("Player_")) {
                div.innerHTML = `<span style="position: absolute;top:50%;right:0;font-size:8px">${cog.icon.substr(8)}` + "</span>";
			  } else {
                div.style.backgroundImage = `url("icons/${cog.icon}.png")`;
			  }
              div.style.backgroundPosition = "center";
              div.style.color = "white";

              // div.innerHTML += `<span style="position: absolute;top:0;left:0;">${cog.buildRate || 0}</span>`;
              // div.innerHTML += `<span style="position: absolute;top:0;right:0;">${cog.expBonus || 0}</span>`;
              // div.innerHTML += `<span style="position: absolute;bottom:0;left:0;">${cog.flaggy || 0}</span>`;
              // div.innerHTML += `<span style="position: absolute;bottom:0;right:0;font-size:6px">${cog.icon}</span>`;

              col.appendChild(div);
            }

            row.appendChild(col);
          }
          
          table.appendChild(row);
        }
        const boardElem = document.getElementById("currentBoard");
        boardElem.innerHTML = "";
        boardElem.appendChild(table);

        console.log("Board updated");
      }
      
      function saveGet(arr, ...indexes) {
        while(indexes.length) {
          if (arr === undefined) break;
          arr = arr[indexes.splice(0, 1)[0]];
        }
        return arr;
      }
      
      f.cloneState = (cogs, board) => {
        const c = {};
        for (let [k,v] of Object.entries(cogs)) {
          c[k] = new Cog(v);
        }
        const b = board.map((r)=>r.map((c)=>{return new Cog(c)}));
        return { cogs: c, board: b };
      }
	  
	    f.removeUselesMoves = (board, cogs) => {
	    const goal = f.getScore(board);
        const cogsToMove = Object.values(cogs)
          .filter((c) => c.key !== c.initialKey);
        // Check if move still changes something
        for (let i = 0; i < cogsToMove.length; i++) {
          const cog1 = cogsToMove[i];
          const cog1Key = cog1.key;
          const pos1 = cog1.position();
          const cog2Key = cog1.initialKey;
          const cog2 = cogs[cog2Key];
          const pos2 = cog2.position();
          if (pos1.location === "board") {
            board[pos1.y][pos1.x] = cog2;
          }
          if (pos2.location === "board") {
            board[pos2.y][pos2.x] = cog1;
          }
		  const changed = f.getScore(board);
		  if (changed.buildRate === goal.buildRate
		    && changed.flaggy === goal.flaggy
			&& changed.expBonus === goal.expBonus) {
            console.log(`Removing useless move ${cog1Key} to ${cog2Key}`);
            cog1.key = cog2Key;
            cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            cogs[cog1Key] = cog2;
			continue;
		  }
          if (pos1.location === "board") {
            board[pos1.y][pos1.x] = cog1;
          }
          if (pos2.location === "board") {
            board[pos2.y][pos2.x] = cog2;
          }
        }
	  }
	  
	    f.printOptimalSteps = (board, cogs) => {
        document.getElementById("steps").innerHTML = "";
        const cogsToMove = Object.values(cogs).map(c=>{return {...c}})
          .filter((c) => c.key !== c.initialKey);
        const interimCogs = {};
        // Remove spare movements
        for (let i = 0; i < cogsToMove.length; i++) {
          const cog = cogsToMove[i];
          if (Number.parseInt(cog.key) < 108 || Number.parseInt(cog.initialKey) < 108) continue;
          console.log(`Removing useless move ${cog.key} to ${cog.initialKey}`);
          const targetCog = cogsToMove.find(c => c.key === cog.initialKey);
          targetCog.key = cog.key;
          cogsToMove.splice(i, 1);
          i--;
        }
        // Easy switches
        for (const cog of cogsToMove) {
          const targetCog = interimCogs[cog.key];
          if (!targetCog || targetCog.initialKey !== cog.key); {
            interimCogs[cog.initialKey] = cog;
            continue;
          }
          f.printMove(board, cog, targetCog);
          delete interimCogs[cog.key];
        }
        // Multi-step movements
        let tuple;
        while (tuple = Object.entries(interimCogs)[0]) {
          const [key, cog] = tuple;
          const targetCog = interimCogs[cog.key];
          if (targetCog === cog) {
            delete interimCogs[key];
            continue;
          }
          interimCogs[key] = targetCog;
          f.printMove(board, cog, targetCog, cog.position(Number.parseInt(key)), targetCog.position(Number.parseInt(cog.key)));
          delete interimCogs[cog.key];
        }
      }

      function load(save) {
        console.log("Loading");
        // Fetch Gem-Shop flaggy upgrades
        document.getElementById("flaggyShop").value = JSON.parse(save["GemItemsPurchased"])[118];
        // Fetch the list of available cogs
        const cogRaw = JSON.parse(save["CogM"]);
        const cogIcons = JSON.parse(save["CogO"]).map(c=>{
          if(c === "Blank") { return c; }
          if(c.startsWith("Player")) { return c; }
          if(c === "CogY") { return "Yang_Cog"; }
          const parsed=c.match(/^Cog([0123YZ])(.{2,3})$/);
          if(parsed[1] === "Z") {
			return YIN_MAP[parsed[2]];
		  }
          return ICON_TYPE_MAP[parsed[2]] + "_" + ICON_QUALITY_MAP[parsed[1]];
        });
        const cogArray = Object.entries(cogRaw).map(([key, c]) => {
          return new Cog({
            key: key,
            initialKey: key,
            icon: cogIcons[key] || "Blank",
            buildRate: c.a,
            isPlayer: c.b > 0,
            expGain: c.b,
            flaggy: c.c,
            expBonus: c.d,
            buildRadiusBoost: c.e,
            expRadiusBoost: c.f,
            flaggyRadiusBoost: c.g,
            boostRadius: c.h,
			flagSpeed: c.j,
			nothing: c.k,
            fixed: c.h === "everything",
            blocked: false
          });
        });
        // Get the available board
        const slots = JSON.parse(save["FlagU"]).map((n) => {
          if(n !== -11) return { fixed: true, blocked: true };
          return {};
        });
        g.cogs = {};
        for (const cog of cogArray) {
          slots[cog.key] = cog;
          g.cogs[cog.key] = cog;
        }
        g.board = [];
        for (let i = 0; i < ROWS; i++) {
          g.board.push(slots.splice(0, COLUMNS));
        }

        const initScore = f.getScore(g.board);
        f.printBoard(g.board);
        document.getElementById("steps").innerHTML = "";
        document.getElementById("buildrate").innerText = initScore.buildRate;
        document.getElementById("xpbonus").innerText = initScore.expBonus;
        document.getElementById("flaggyrate").innerText = initScore.flaggy;
      }

      function toResultString(num) {
        if (num >= 0) {
          return `+${num}`;
        } else {
          return num.toString();
        }
      }
      
      document.getElementById("fetch").addEventListener("click", (ev) => {
        const input = document.getElementById("input");
        const name = input.value;
        console.log("Trying to fetch", name);
        if (name.length > 0) {
          const headers = {
            "Content-Type": "text/json",
            method: "GET"
          };
          fetch(`https://cdn.idleonefficiency.com/profiles/${name.toLowerCase()}.json`, headers)
          .then((response) => {
            return response.json();
          }).then((json) => {
            load(json);
          }).catch((reason) => {
            console.log(reason);
          })
        }
      });

      document.getElementById("load").addEventListener("click", () => {
        const save = JSON.parse(document.getElementById("input").value);
        load(save);
      });
      
      document.getElementById("solve").onclick = async () => {
	    const solveTime = getInput("solveTime") || 1000;
	    document.getElementById("solve").innerText = "Optimizing...";
		await new Promise(r=>setTimeout(r,1));
        const steps = document.getElementById("steps");
        steps.innerHTML = "";
        const printMove = (board, cog1, cog2, pos1, pos2) => {
          const toAdd = document.createElement("p");
          toAdd.innerText = `Switch ${pos1.location}[${pos1.x + 1}|${pos1.y + 1}] (${cog1.buildRate || 0}:${cog1.expBonus || 0}:${cog1.flaggy || 0}) with ${pos2.location}[${pos2.x + 1}|${pos2.y + 1}] (${cog2.buildRate || 0}:${cog2.expBonus || 0}:${cog2.flaggy || 0})`;
          toAdd.onclick = () => f.printBoard(board, pos1, pos2);
          steps.appendChild(toAdd);
        }
        
        const shuffledStart = () => {
          const state = f.cloneState(g.cogs, g.board);
          state.score = f.getScore(state.board);
          state.scoreSum = f.getScoreSum(state.score);
          solutions.push(state);
          const allKeys = Object.keys(state.cogs);
          for (let i = 0; i < 500; i++) {
            const cog1Key = allKeys[Math.floor(Math.random() * allKeys.length)];
            const cog1 = state.cogs[cog1Key]
            const pos1 = cog1.position();
            const cog2Key = allKeys[Math.floor(Math.random() * allKeys.length)];
            const cog2 = state.cogs[cog2Key];
            const pos2 = cog2.position();
            if (cog1.fixed || cog2.fixed || pos1.location === "build" || pos2.location === "build") continue;
            if (pos1.location === "board") {
              state.board[pos1.y][pos1.x] = cog2;
            }
            if (pos2.location === "board") {
              state.board[pos2.y][pos2.x] = cog1;
            }
            cog1.key = cog2Key;
            state.cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            state.cogs[cog1Key] = cog2;
          }
          return state;
        }

        console.log("Starting");

        let state = f.cloneState(g.cogs, g.board);
        state.score = f.getScore(state.board);
        state.scoreSum = f.getScoreSum(state.score);

        const initBuildRate = state.score.buildRate;
        const initExpBonus = state.score.expBonus;
        const initFlaggy = state.score.flaggy;
        const initScore = state.scoreSum;

        document.getElementById("start").innerText = `Starting BuildRate: ${state.score.buildRate}, EXP: ${state.score.expBonus}, Flaggy: ${state.score.flaggy}, Sum: ${state.scoreSum}`;
        const solutions = [state];
        const allKeys = Object.keys(g.cogs);
        const startTime = Date.now();
        let counter = 0;
        console.log("Trying to optimize");
        while(Date.now() - startTime < solveTime) {
          counter++;
          if (counter % 10000 === 0) {
            f.verifyBoardIntegrity(state.board);
            state = shuffledStart();
          }
          const cog1Key = allKeys[Math.floor(Math.random() * allKeys.length)];
          const cog1 = state.cogs[cog1Key]
          const pos1 = cog1.position();
          const cog2Key = allKeys[Math.floor(Math.random() * allKeys.length)];
          const cog2 = state.cogs[cog2Key];
          const pos2 = cog2.position();
          if (pos1.location !== "board" && pos2.location !== "board") continue;
          if (cog1.fixed || cog2.fixed || pos1.location === "build" || pos2.location === "build") continue;
          if (pos1.location === "board") {
            state.board[pos1.y][pos1.x] = cog2;
          }
          if (pos2.location === "board") {
            state.board[pos2.y][pos2.x] = cog1;
          }
          const scoreUpdate = f.getScore(state.board);
          const scoreSumUpdate = f.getScoreSum(scoreUpdate);
          if (scoreSumUpdate > state.scoreSum) {
            state.score = scoreUpdate;
            state.scoreSum = scoreSumUpdate;
            
            cog1.key = cog2Key;
            state.cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            state.cogs[cog1Key] = cog2;
          } else {
            if (pos1.location === "board") {
              state.board[pos1.y][pos1.x] = cog1;
            }
            if (pos2.location === "board") {
              state.board[pos2.y][pos2.x] = cog2;
            }
          }
        }
        console.log(`Tried ${counter} switches`);
        console.log(`Made ${solutions.length} different attempts with final scores: ${solutions.map(s=>s.scoreSum)}`);
        let best = solutions.reduce((a, b) => a.scoreSum >= b.scoreSum ? a : b);
        const bestIndex = solutions.indexOf(best);
        if (g.best === null || g.best.scoreSum < best.scoreSum) {
          console.log("Best solution was number", bestIndex);
          g.best = best;
        } else {
          best = g.best;
        }
        if (best.scoreSum !== f.getScoreSum(f.getScore(best.board))) {
          debugger;
        }
        for (let i = 1; i <= 5; i++) {
          console.log("Removing usless moves", i);
          f.removeUselesMoves(best.board, best.cogs);
        }
        f.verifyBoardIntegrity(best.board);
        if (best.scoreSum !== f.getScoreSum(f.getScore(best.board))) {
          debugger;
        }
        document.getElementById("end").innerText = `Final BuildRate: ${best.score.buildRate}, EXP: ${best.score.expBonus}, Flaggy: ${best.score.flaggy}, Sum: ${best.scoreSum}`;
        
        document.getElementById("buildrate").innerText = `${toResultString(best.score.buildRate - initBuildRate)}/HR`;
        document.getElementById("xpbonus").innerText = `${toResultString(best.score.expBonus - initExpBonus)}%`;
        document.getElementById("flaggyrate").innerText = `${toResultString(best.score.flaggy - initFlaggy)}/HR`;
        
        f.printOptimalSteps(best.board, best.cogs);
        f.printBoard(best.board);
	      document.getElementById("solve").innerText = "Solve";
      };
    </script>
  </body>
</html>
