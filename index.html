<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="dark light" />

    <link rel="stylesheet" href="style.css" />
    <script type="text/javascript" src="Solver.js"></script>
    <script type="text/javascript" src="BoardRenderer.js"></script>
    <script type="text/javascript" src="Paginator.js"></script>
    
    <title>IdleOn optimizer</title>
  </head>
  <body>
    <div class="inputarea">
      <textarea type="textarea" id="input" rows="10" cols="100"></textarea>
      <div>
        <button id="fetch" style="max-width: 15ch;">Fetch</button>
        <button id="load" style="max-width: 15ch;">Load</button>
        <button id="solve" style="max-width: 15ch;">Solve</button>
      </div>
    </div>
    <ul class="menu">
      <li id="settingsbtn" class="active">Settings</li>
      <li id="cogbtn">Cogs</li>
    </ul>
    <div class="content">
      <div id="settings">
        <p>
          <label for="flaggyShop">Gem Shop Flaggy upgrades</label>
          <input type="number" id="flaggyShop" value="0" style="width:6ch" disabled=true></input>
        </p>
        <p>
          <label for="buildRate">Build rate score weight</label>
          <input type="number" id="buildRate" value="2" style="width:6ch"></input>
        </p>
        <p>
          <label for="expBonus">EXP Bonus score weight</label>
          <input type="number" id="expBonus" value="50" style="width:6ch"></input>
        </p>
        <p>
          <label for="flaggy">Flaggy rate score weight</label>
          <input type="number" id="flaggy" value="5" style="width:6ch"></input>
        </p>
        <p>
          <label for="solveTime">Solve times (ms)</label>
          <input type="number" id="solveTime" value="1000" style="width:10ch"></input>
        </p>
      </div>
      <div id="result">
        <div class="info">
          <div id="spare">---Placeholder---</div>
          <div id="sparepage"></div>
          <div class="stats">
            <span class="buildrate">
              <h3>Total Build Rate</h3>
              <p id="buildrate">Please</p>
            </span>
            <span class="xpbonus">
              <h3>Player XP Bonus</h3>
              <p id="xpbonus">load a</p>
            </span>
            <span class="flaggyrate">
              <h3>Flaggy Rate</h3>
              <p id="flaggyrate">Savegame</p>
            </span>
          </div>
        </div>
        <div class="border"></div>
        <div id="currentBoard">
        </div>
        <div id="steps"></div>
      </div>
    </div>
    <p id="start"></p>
    <p id="end"></p>
    <script type="text/javascript">
      const ROWS = 8;
      const COLUMNS = 12;
      const OPTIMIZABLE = ["buildRate", "expBonus", "flaggy"];
      const ICON_QUALITY_MAP = {
        ["0"]: "Nooby",
        ["1"]: "Decent",
        ["2"]: "Superb",
        ["3"]: "Ultimate",
        ["Y"]: "Yang",
        ["Z"]: "Yin"
      };
      const ICON_TYPE_MAP = {
        ["A00"]: "Cog",
        ["A0"]: "CogB",
        ["A1"]: "Average",
        ["A2"]: "Spur",
        ["A3"]: "Stacked",
        ["A4"]: "Deckered",
        ["B0"]: "Double",
        ["B1"]: "Trips",
        ["B2"]: "Trabble",
        ["B3"]: "Quad",
        ["B4"]: "Penta",
        ["ad"]: "Adjacent",
        ["di"]: "Diagonal",
        ["up"]: "Up",
        ["do"]: "Down",
        ["le"]: "Left",
        ["ri"]: "Right",
        ["ro"]: "Row",
        ["co"]: "Column",
        ["cr"]: "Corner",
      };
      const YIN_MAP = {
        ["A00"]: "Yin_Top_Left_Cog",
        ["A01"]: "Yin_Top_Right_Cog",
        ["A02"]: "Yin_Bottom_Left_Cog",
        ["A03"]: "Yin_Bottom_Right_Cog"
      };
      
      const getInput = (id) => Number.parseInt(document.getElementById(id).value);
      const getFlaggyShop = getInput.bind(null, "flaggyShop");

      const cogBlank = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpUWrDnYQcchQO1koKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIo5OToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eKKBqlpGKx8RsblX0vaIffgwiirDETD2RXsyg6/i6h4evdxGe1f3cn2NAyZsM8IjEc0w3LOIN4plNS+e8TxxkJUkhPieeMOiCxI9cl11+41x0WOCZQSOTmicOEovFDpY7mJUMlXiaOKSoGuULWZcVzluc1UqNte7JXxjIaytprtMcQxxLSCAJETJqKKMCCxFaNVJMpGg/1sU/6viT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMCMaD3xbY/xgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rYWOgKFt4OK6rcl7wOUOMPKkS4bkSF6aQqEAvJ/RN+WA4Vugb83trbWP0wcgQ10t3wAHh0C4SNnrXd7t7+zt3zOt/n4AuHlyw22PBoIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfmCwgOMhatl4frAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAARNJREFUWMPtmM0KgzAMxzMJgiAivsQeZI+y9xdRURBhO+wwKWmSxh56SI7a/vPLh2nx8X49P1CgIQDA0NVFQY3zARUUag5m6jFNzS12p3cxNwylYQFEDkgjqAkgXKPRRU6AchqKck5i0JrgMXQiZUADG3tO7R3ng9yPlFhqf8XWa7NLZRAlQQkyx6khZowilyCt4Ny+ad3/YFLjD12dpczXgDktnNY9eSbdmXFUVSi96o5wjgEc+yqLOCuzZMyvPQ7GzCxqMqBFqG+bpPWcxbQwVTgU0s5BLRALJsFYgaSgru9Rcta3jTkrqTrXNqlCqFylsmZ4WndYthNw2U4A2LOD+BxzMAdzMAdzMMPfnt+xVJZ9ATWPsYm30CgcAAAAAElFTkSuQmCC";
      const cogBg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpUWrDnYQcchQO1koKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIo5OToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eKKBqlpGKx8RsblX0vaIffgwiirDETD2RXsyg6/i6h4evdxGe1f3cn2NAyZsM8IjEc0w3LOIN4plNS+e8TxxkJUkhPieeMOiCxI9cl11+41x0WOCZQSOTmicOEovFDpY7mJUMlXiaOKSoGuULWZcVzluc1UqNte7JXxjIaytprtMcQxxLSCAJETJqKKMCCxFaNVJMpGg/1sU/6viT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMCMaD3xbY/xgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rYWOgKFt4OK6rcl7wOUOMPKkS4bkSF6aQqEAvJ/RN+WA4Vugb83trbWP0wcgQ10t3wAHh0C4SNnrXd7t7+zt3zOt/n4AuHlyw22PBoIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfmCwgOOyi9NCEJAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAVRJREFUWMPtmDEKwjAUhp/liS09gFcoODg6eYFunsClZ/ASXsFLuHgBvYLg2FXcCmJLBR3EEmOal6TBRsibSpr8/5f3khAyWC9nD3AwEABgszsBAECWJs33r4P1ztIEAnA08E3oQrAcH6XsM1iGLE1eYFSMwqGRWVXW3UppE0akYQKIMiAVQZUJ8H1UdFEmIDLlRWUmbdAqk0fehMqACmxbu2jsKBwKx6NITHd9tfVXza4og0gJUpBddp5MAylyCtIUnBqHqgu/KmsrZWYnLNNC3S1vAkdVRaQXdBG2cQC37UonbhdWMvar8GB/BxZHCHH0fc7jpSi1ha63u1Z/WYi0LkVJXxR5YV6IMtYBIi+KFIwpEDUp9j+qmJlmRVeHXSaBbXNb8IFLUP4c82AezIOZvl3MJ+OmYX889wLCMjQZ2x5y2B7y3rPEcjhbysFqMXXycfgJ3ImUN+Kk6UcAAAAASUVORK5CYII=";

      const createElem = function createElem(tagName, style=undefined) {
        const elem = document.createElement(tagName);
        if (style) {
          elem.style = style;
        }
        return elem;
      }

      Cog = function (initialValues = {}) {
        return {
          _key: initialValues.key,
          get key() { return this._key },
          set key(v) { this._position = null; this._key = v },
          icon: initialValues.icon,
          initialKey: initialValues.initialKey,
          buildRate: initialValues.buildRate,
          isPlayer: initialValues.isPlayer,
          expGain: initialValues.expGain,
          flaggy: initialValues.flaggy,
          expBonus: initialValues.expBonus,
          buildRadiusBoost: initialValues.buildRadiusBoost,
          expRadiusBoost: initialValues.expRadiusBoost,
          flaggyRadiusBoost: initialValues.flaggyRadiusBoost,
          boostRadius: initialValues.boostRadius,
          flagSpeed: initialValues.flagSpeed,
          nothing: initialValues.nothing, // Description: Nothing LoL
          fixed: initialValues.fixed,
          blocked: initialValues.blocked,
          _position: null,
          position(keyNum) {
            if (this._position && !keyNum) return this._position;
            keyNum = keyNum || Number.parseInt(this.key);
            // build = 97-107
            // spare = 108-*
            // board = 0-96
            const location = keyNum >= 96 ? keyNum <= 107 ? "build" : "spare" : "board";
            let perRow = 3;
            let offset = 108;
            if (location === "board") {
              perRow = 12;
              offset = 0;
            } else if (location === "build") {
              offset = 96;
            }
            const y = Math.floor((keyNum - offset) / perRow);
            const x = Math.floor((keyNum - offset) % perRow);
            return this._position = { location, x, y };
          }
        };
      }
      
      window.g = {
        cogs: {},
        board: [],
        best: null
      };
      window.f = {};

      window.boardRenderer = new BoardRenderer(ROWS, COLUMNS, "board");
      window.spareRenderer = new BoardRenderer(30, 3, "spare", 5);
      window.solver = new Solver();

      const sparePage = new Paginator("sparepage", window.spareRenderer._pageCount, 1);
      sparePage.addEventListener("change", (ev) => {
        window.spareRenderer.showPage(ev.page);
      });

      const boardElem = document.getElementById("currentBoard");
      boardElem.innerHTML = "";
      // boardElem.appendChild(table);
      boardElem.appendChild(window.boardRenderer.createHTMLElement());

      const stepContainer = createElem("div");
      stepContainer.id = "stepspage";
      boardElem.appendChild(stepContainer);
      const stepsPage = new Paginator("stepspage", 0, 0, "Step");
      stepsPage.addEventListener("change", console.log);


      const spareElem = document.getElementById("spare");
      const spareParent = spareElem.parentNode;
      spareParent.insertBefore(window.spareRenderer.createHTMLElement(), spareElem);
      spareParent.removeChild(spareElem);
      
      f.verifyBoardIntegrity = (board) => {
        for (let y = 0; y < board.length; y++) {
          for (let x = 0; x < board[y].length; x++) {
            if (board[y][x].blocked) continue;
            const tempPos = board[y][x].position();
            if (tempPos.x !== x || tempPos.y !== y) {
              debugger;
            }
          }
        }
      }
      
      f.getScore = (board) => {
        const result = {
          buildRate: 0,
          expBonus: 0,
          flaggy: 0
        };
        const bonusGrid = Array(ROWS).fill(0).map(() => { return Array(COLUMNS).fill(0).map(() => { return { ...result } })});
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            const boosted = [];
            switch (entry.boostRadius) {
              case "diagonal":
                boosted.push([i-1, j-1],[i-1, j+1],[i+1, j-1],[i+1, j+1]);
                break;
              case "adjacent":
                boosted.push([i-1, j],[i, j+1],[i+1, j],[i, j-1]);
                break;
              case "up":
                boosted.push([i-2, j-1],[i-2, j],[i-2, j+1],[i-1, j-1],[i-1, j],[i-1, j+1]);
                break;
              case "right":
                boosted.push([i-1, j+2],[i, j+2],[i+1, j+2],[i-1, j+1],[i, j+1],[i+1, j+1]);
                break;
              case "down":
                boosted.push([i+2, j-1],[i+2, j],[i+2, j+1],[i+1, j-1],[i+1, j],[i+1, j+1]);
                break;
              case "left":
                boosted.push([i-1, j-2],[i, j-2],[i+1, j-2],[i-1, j-1],[i, j-1],[i+1, j-1]);
                break;
              case "row":
                for (let k = 0; k < COLUMNS; k++) {
                  if(j == k) continue;
                  boosted.push([i, k]);
                }
                break;
              case "column":
                for (let k = 0; k < ROWS; k++) {
                  if(i == k) continue;
                  boosted.push([k, j]);
                }
                break;
              case "corner":
                boosted.push([i-2, j-2],[i-2, j+2],[i+2, j-2],[i+2, j+2]);
                break;
              case "around":
                boosted.push([i-2, j],[i-1, j-1],[i-1, j],[i-1, j+1],[i, j-2],[i, j-1],[i, j+1],[i, j+2],[i+1, j-1],[i+1, j],[i+1, j+1],[i+2, j]);
                break;
              case "excogia":
                for (let k = 0; k < ROWS; k++) {
                  for (let l = 0; l < COLUMNS; l++) {
                    if(i === k && j === l) continue;
                    boosted.push([k, l]);
                  }
                }
                break;
              default:
                break;
            }
            for (const boostCord of boosted) {
              const bonus = saveGet(bonusGrid, ...boostCord);
              if (!bonus) continue;
              bonus.buildRate += entry.buildRadiusBoost  || 0;
              bonus.expBonus  += entry.expRadiusBoost    || 0;
              bonus.flaggy    += entry.flaggyRadiusBoost || 0;
            }
          }
        }
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            result.buildRate += entry.buildRate || 0;
            result.expBonus += entry.expBonus || 0;
            result.flaggy += entry.flaggy || 0;
            const bonus = bonusGrid[i][j];
            if (!bonus) continue;
            const b = (bonus.buildRate || 0) / 100;
            result.buildRate += Math.ceil((entry.buildRate || 0) * b);
            const e = (bonus.expBonus || 0) / 100;
            result.expBonus += Math.ceil((entry.expBonus || 0) * e);
            const f = (bonus.flaggy || 0) / 100;
            result.flaggy += Math.ceil((entry.flaggy || 0) * f);
          }
        }
        result.flaggy = Math.floor(result.flaggy * (1 + getFlaggyShop() * 0.5));
        return result;
      }
      
      f.getScoreSum = (score) => {
        let res = 0;
        for (const opt of OPTIMIZABLE) {
          res += score[opt] * getInput(opt);
        }
        return res;
      }

      let moveIndex = 0;
      //TODO Paddy: Kann so schlecht resettet werden (und wird aktuell nicht genutzt)
      const moves = [];
      
      f.printMove = (board, cog1, cog2, pos1, pos2) => {
        moves.push({pos1, pos2});
        const toAdd = createElem("p");
        toAdd.innerHTML = `Switch ${pos1.location} \
        [${pos1.x + 1}|${pos1.y + 1}] \
        (${cog1.buildRate || 0}:${cog1.expBonus || 0}:${cog1.flaggy || 0}) <span style="background-image:url('icons/${cog1.icon}.png')"></span> with \
        ${pos2.location} \
        [${pos2.x + 1}|${pos2.y + 1}] \
        (${cog2.buildRate || 0}:${cog2.expBonus || 0}:${cog2.flaggy || 0}) <span style="background-image:url('icons/${cog2.icon}.png')"></span>`;
        toAdd.onclick = () => {
          window.boardRenderer.move(pos1, pos2);
          window.spareRenderer.move(pos1, pos2);
        }
        document.getElementById("steps").appendChild(toAdd);
      }
      
      f.printBoard = (board, cord1={},cord2={}) => {
        for (let i = 0; i < board.length; i++) {
          const row = createElem("tr");
          
          for (let j = 0; j < board[i].length; j++) {
            window.boardRenderer.set(i, j, board[i][j]);
          }
        }

        console.log("Board updated");
      }
      
      function saveGet(arr, ...indexes) {
        while(indexes.length) {
          if (arr === undefined) break;
          arr = arr[indexes.splice(0, 1)[0]];
        }
        return arr;
      }
      
      function yield() {
        return new Promise(r=>setTimeout(r,1));
      }
      
      f.cloneState = (cogs, board) => {
        const c = {};
        for (let [k,v] of Object.entries(cogs)) {
          c[k] = new Cog(v);
        }
        const b = board.map((r)=>r.map((c)=>{return new Cog(c)}));
        return { cogs: c, board: b };
      }
      
      f.printOptimalSteps = (board, cogs) => {
        document.getElementById("steps").innerHTML = "";
        const cogsToMove = Object.values(cogs).map(c=>{return {...c}})
          .filter((c) => c.key !== c.initialKey);
        const interimCogs = {};
        // Remove spare movements
        for (let i = 0; i < cogsToMove.length; i++) {
          const cog = cogsToMove[i];
          if (Number.parseInt(cog.key) < 108 || Number.parseInt(cog.initialKey) < 108) continue;
          console.log(`Removing useless move ${cog.key} to ${cog.initialKey}`);
          const targetCog = cogsToMove.find(c => c.key === cog.initialKey);
          targetCog.key = cog.key;
          cogsToMove.splice(i, 1);
          i--;
        }
        // Easy switches
        for (const cog of cogsToMove) {
          const targetCog = interimCogs[cog.key];
          if (!targetCog || targetCog.initialKey !== cog.key); {
            interimCogs[cog.initialKey] = cog;
            continue;
          }
          f.printMove(board, cog, targetCog, cog.position(Number.parseInt(key)), targetCog.position(Number.parseInt(cog.key)));
          delete interimCogs[cog.key];
        }
        // Multi-step movements
        let tuple;
        while (tuple = Object.entries(interimCogs)[0]) {
          const [key, cog] = tuple;
          const targetCog = interimCogs[cog.key];
          if (targetCog === cog) {
            delete interimCogs[key];
            continue;
          }
          interimCogs[key] = targetCog;
          f.printMove(board, cog, targetCog, cog.position(Number.parseInt(key)), targetCog.position(Number.parseInt(cog.key)));
          delete interimCogs[cog.key];
        }
      }

      function mmoifyNumber(num, addSign = true) {
        let str = num;

        if (Math.abs(num) >= 1000000) {
          str = (Math.ceil(num / 10000) / 100) + "M";
        } else if (Math.abs(num) >= 1000) {
          str = (Math.ceil(num / 10) / 100) + "K";
        }

        if (addSign && num >= 0) {
          str = "+" + str;
        }

        return str.toString();
      }

      function load(save) {
        console.log("Loading");
        // Fetch Gem-Shop flaggy upgrades
        document.getElementById("flaggyShop").value = JSON.parse(save["GemItemsPurchased"])[118];
        // Fetch the list of available cogs
        const cogRaw = JSON.parse(save["CogM"]);
        let i = 0;
        const cogIcons = JSON.parse(save["CogO"]).map(c=>{
          if(c === "Blank") { return c; }
          if(c.startsWith("Player")) { return c; }
          if(c === "CogY") { return "Yang_Cog"; }
          const parsed=c.match(/^Cog([0123YZ])(.{2,3})$/);
          if(parsed[1] === "Z") {
            return YIN_MAP[parsed[2]];
          }
          return ICON_TYPE_MAP[parsed[2]] + "_" + ICON_QUALITY_MAP[parsed[1]];
        });
        const cogArray = Object.entries(cogRaw).map(([key, c]) => {
          return new Cog({
            key: key,
            initialKey: key,
            icon: cogIcons[key] || "Blank",
            buildRate: c.a,
            isPlayer: c.b > 0,
            expGain: c.b,
            flaggy: c.c,
            expBonus: c.d,
            buildRadiusBoost: c.e,
            expRadiusBoost: c.f,
            flaggyRadiusBoost: c.g,
            boostRadius: c.h,
            flagSpeed: c.j,
            nothing: c.k,
            fixed: c.h === "everything" || c.j > 0,
            blocked: false
          });
        });
        // Get the available board
        const slots = JSON.parse(save["FlagU"]).map((n) => {
          if(n !== -11) return { fixed: true, blocked: true };
          return {};
        });
        g.cogs = {};
        for (const cog of cogArray) {
          slots[cog.key] = cog;
          g.cogs[cog.key] = cog;
        }
        window.spareRenderer.showPage(0);
        sparePage.goto(0);
        for (let i = 108; i < slots.length; i++) {
          const index = (i - 108);
          const row = Math.floor(index / 3); // 3 since the spare board has 3 columns per row
          const col = index % 3;
          window.spareRenderer.set(row, col, slots[i]);
        };
        g.board = [];
        for (let i = 0; i < ROWS; i++) {
          g.board.push(slots.splice(0, COLUMNS));
        }

        const initScore = f.getScore(g.board);
        f.printBoard(g.board);
        openCogTab();
        document.getElementById("steps").innerHTML = "";
        document.getElementById("buildrate").innerText = mmoifyNumber(initScore.buildRate, false) + "/HR";
        document.getElementById("xpbonus").innerText = mmoifyNumber(initScore.expBonus, false) + "%";
        document.getElementById("flaggyrate").innerText = mmoifyNumber(initScore.flaggy, false) + "/HR";
      }
      
      document.getElementById("fetch").addEventListener("click", (ev) => {
        const input = document.getElementById("input");
        const name = input.value;
        console.log("Trying to fetch", name);
        if (name.length > 0) {
          const headers = {
            "Content-Type": "text/json",
            method: "GET"
          };
          fetch(`https://cdn.idleonefficiency.com/profiles/${name.toLowerCase()}.json`, headers)
          .then((response) => {
            return response.json();
          }).then((json) => {
            load(json);
          }).catch((reason) => {
            console.log(reason);
          })
        }
      });

      document.getElementById("load").addEventListener("click", () => {
        const save = JSON.parse(document.getElementById("input").value);
        load(save);
      });
      
      document.getElementById("solve").onclick = async () => {
        const solveTime = getInput("solveTime") || 1000;
        document.getElementById("solve").innerText = "Optimizing...";
        document.getElementById("steps").innerHTML = "";
        let lastYield = Date.now();
        await yield(); // Yield for DOM-Refresh

        console.log("Starting");

        let start = f.cloneState(g.cogs, g.board);
        start.score = f.getScore(start.board);
        start.scoreSum = f.getScoreSum(start.score);

        document.getElementById("start").innerText = `Starting BuildRate: ${start.score.buildRate}, EXP: ${start.score.expBonus}, Flaggy: ${start.score.flaggy}, Sum: ${start.scoreSum}`;
        const best = await solver.solve(solveTime);
        document.getElementById("end").innerText = `Final BuildRate: ${best.score.buildRate}, EXP: ${best.score.expBonus}, Flaggy: ${best.score.flaggy}, Sum: ${best.scoreSum}`;
        
        document.getElementById("buildrate").innerText = `${mmoifyNumber(best.score.buildRate - start.score.buildRate)}/HR`;
        document.getElementById("xpbonus").innerText = `${mmoifyNumber(best.score.expBonus - start.score.expBonus)}%`;
        document.getElementById("flaggyrate").innerText = `${mmoifyNumber(best.score.flaggy - start.score.flaggy)}/HR`;
        
        f.printOptimalSteps(best.board, best.cogs);
        // f.printBoard(best.board);
        // TODO Paddy: This opens the original board, not the board after solving
        openCogTab();
        document.getElementById("solve").innerText = "Solve";
      };
    
      function openCogTab() {
        document.getElementById("settings").style.display = "none";
        document.getElementById("result").style.display = "inherit";

        document.getElementById("settingsbtn").className = "";
        document.getElementById("cogbtn").className = "active";
      }

      function openSettingsTab() {
        document.getElementById("settings").style.display = "inherit";
        document.getElementById("result").style.display = "none";

        document.getElementById("settingsbtn").className = "active";
        document.getElementById("cogbtn").className = "";
      }

      document.getElementById("settingsbtn").addEventListener("click", () => {
        openSettingsTab();
      });
      document.getElementById("cogbtn").addEventListener("click", () => {
        openCogTab();
      });
    </script>
  </body>
</html>
