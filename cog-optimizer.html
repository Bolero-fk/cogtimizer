<html>
  <body style="display: flex;flex-direction: column;max-height: 98vh;">
    <textarea type="textarea" id="input" rows="10" cols="100"></textarea>
    <button id="load" style="max-width: 15ch;">Load</button>
    <p>
      <label for="flaggyShop">Gem Shop Flaggy upgrades</label>
      <input type="number" id="flaggyShop" value="0" style="width:6ch" disabled=true></input>
    </p>
    <p>
      <label for="buildRate">Build rate score weight</label>
      <input type="number" id="buildRate" value="2" style="width:6ch"></input>
    </p>
    <p>
      <label for="expBonus">EXP Bonus score weight</label>
      <input type="number" id="expBonus" value="50" style="width:6ch"></input>
    </p>
    <p>
      <label for="flaggy">Flaggy rate score weight</label>
      <input type="number" id="flaggy" value="5" style="width:6ch"></input>
    </p>
    <p>
      <label for="solveTime">Solve times (ms)</label>
      <input type="number" id="solveTime" value="1000" style="width:10ch"></input>
    </p>
    <button id="solve" style="max-width: 15ch;">Solve</button>
    <div style="display: flex;flex-direction: row;min-height: 0;">
      <div style="display: flex;flex-direction: column;">
        <div id="currentBoard"></div>
        <p id="start"></p>
        <p id="end"></p>
      </div>
      <div id="steps" style="overflow: auto;min-height: 100px;"></div>
    </div>
    <script type="text/javascript">
      const ROWS = 8;
      const COLUMNS = 12;
      const OPTIMIZABLE = ["buildRate", "expBonus", "flaggy"];
      
      const getInput = (id) => Number.parseInt(document.getElementById(id).value);
      const getFlaggyShop = getInput.bind(null, "flaggyShop");
      
      Cog = function (initialValues = {}) {
        return {
          _key: initialValues.key,
          get key() { return this._key },
          set key(v) { this._position = null; this._key = v },
          initialKey: initialValues.initialKey,
          buildRate: initialValues.buildRate,
          isPlayer: initialValues.isPlayer,
          expGain: initialValues.expGain,
          flaggy: initialValues.flaggy,
          expBonus: initialValues.expBonus,
          buildRadiusBoost: initialValues.buildRadiusBoost,
          expRadiusBoost: initialValues.expRadiusBoost,
          flaggyRadiusBoost: initialValues.flaggyRadiusBoost,
          boostRadius: initialValues.boostRadius,
		  icon: initialValues.icon,
          fixed: initialValues.fixed,
          blocked: initialValues.blocked,
          _position: null,
          position(keyNum) {
            if (this._position && !keyNum) return this._position;
            keyNum = keyNum || Number.parseInt(this.key);
            const location = keyNum >= 95 ? keyNum <= 107 ? "build" : "spare" : "board";
            let perRow = 3;
            let offset = 108;
            if (location === "board") {
              perRow = 12;
              offset = 0;
            } else if (location === "build") {
              offset = 96;
            }
            const y = Math.floor((keyNum - offset) / perRow);
            const x = Math.floor((keyNum - offset) % perRow);
            return this._position = { location, x, y };
          }
        };
      }
      
      window.g = {
        cogs: {},
        board: [],
        best: null
      };

      window.f = {};
      
      f.verifyBoardIntegrity = (board) => {
        for (let y = 0; y < board.length; y++) {
          for (let x = 0; x < board[y].length; x++) {
            if (board[y][x].blocked) continue;
            const tempPos = board[y][x].position();
            if (tempPos.x !== x || tempPos.y !== y) {
              debugger;
            }
          }
        }
      }
      
      f.getScore = (board) => {
        const result = {
          buildRate: 0,
          expBonus: 0,
          flaggy: 0
        };
        const bonusGrid = Array(ROWS).fill(0).map(() => { return Array(COLUMNS).fill(0).map(() => { return { ...result } })});
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            const boosted = [];
            switch (entry.boostRadius) {
              case "diagonal":
                boosted.push([i-1, j-1],[i-1, j+1],[i+1, j-1],[i+1, j+1]);
                break;
              case "adjacent":
                boosted.push([i-1, j],[i, j+1],[i+1, j],[i, j-1]);
                break;
              case "up":
                boosted.push([i-2, j-1],[i-2, j],[i-2, j+1],[i-1, j-1],[i-1, j],[i-1, j+1]);
                break;
              case "right":
                boosted.push([i-1, j+2],[i, j+2],[i+1, j+2],[i-1, j+1],[i, j+1],[i+1, j+1]);
                break;
              case "down":
                boosted.push([i+2, j-1],[i+2, j],[i+2, j+1],[i+1, j-1],[i+1, j],[i+1, j+1]);
                break;
              case "left":
                boosted.push([i-1, j-2],[i, j-2],[i+1, j-2],[i-1, j-1],[i, j-1],[i+1, j-1]);
                break;
              case "row":
                for (let k = 0; k < COLUMNS; k++) {
                  if(j == k) continue;
                  boosted.push([i, k]);
                }
                break;
              case "column":
                for (let k = 0; k < ROWS; k++) {
                  if(i == k) continue;
                  boosted.push([k, j]);
                }
                break;
              case "corner":
                boosted.push([i-2, j-2],[i-2, j+2],[i+2, j-2],[i+2, j+2]);
                break;
              case "around":
                boosted.push([i-2, j],[i-1, j-1],[i-1, j],[i-1, j+1],[i, j-2],[i, j-1],[i, j+1],[i, j+2],[i+1, j-1],[i+1, j],[i+1, j+1],[i+2, j]);
                break;
              case "excogia":
                for (let k = 0; k < ROWS; k++) {
                  for (let l = 0; l < COLUMNS; l++) {
                    if(i === k && j === l) continue;
                    boosted.push([k, l]);
                  }
                }
                break;
              default:
                break;
            }
            for (const boostCord of boosted) {
              const bonus = saveGet(bonusGrid, ...boostCord);
              if (!bonus) continue;
              bonus.buildRate += entry.buildRadiusBoost  || 0;
              bonus.expBonus  += entry.expRadiusBoost    || 0;
              bonus.flaggy    += entry.flaggyRadiusBoost || 0;
            }
          }
        }
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            const entry = board[i][j];
            if (!entry) continue;
            result.buildRate += entry.buildRate || 0;
            result.expBonus += entry.expBonus || 0;
            result.flaggy += entry.flaggy || 0;
            const bonus = bonusGrid[i][j];
            if (!bonus) continue;
            const b = (bonus.buildRate || 0) / 100;
            result.buildRate += Math.ceil((entry.buildRate || 0) * b);
            const e = (bonus.expBonus || 0) / 100;
            result.expBonus += Math.ceil((entry.expBonus || 0) * e);
            const f = (bonus.flaggy || 0) / 100;
            result.flaggy += Math.ceil((entry.flaggy || 0) * f);
          }
        }
        result.flaggy = Math.floor(result.flaggy * (1 + getFlaggyShop() * 0.5));
        return result;
      }
      
      f.getScoreSum = (score) => {
        let res = 0;
        for (const opt of OPTIMIZABLE) {
          res += score[opt] * getInput(opt);
        }
        return res;
      }
	  
	  f.printMove = (board, cog1, cog2, pos1, pos2) => {
        const toAdd = document.createElement("p");
        toAdd.innerText = `Switch ${pos1.location}[${pos1.x + 1}|${pos1.y + 1}] (${cog1.buildRate || 0}:${cog1.expBonus || 0}:${cog1.flaggy || 0}) with ${pos2.location}[${pos2.x + 1}|${pos2.y + 1}] (${cog2.buildRate || 0}:${cog2.expBonus || 0}:${cog2.flaggy || 0})`;
        toAdd.onclick = () => f.printBoard(board, pos1, pos2);
        steps.appendChild(toAdd);
      }
      
      f.printBoard = (board, cord1={},cord2={}) => {
        const boardHtml = document.getElementById("currentBoard");
        const tableBuilder = [];
        tableBuilder.push("<table>");
        for (let i = 0; i < board.length; i++) {
          tableBuilder.push("<tr style=\"height: 30px;min-height: 30px;max-height: 30px;\">");
          for (let j = 0; j < board[i].length; j++) {
            const cog = board[i][j];
            let border = "black";
            if (cog.blocked) {
              border = "red";
            } else if (cog.fixed) {
              border = "yellow";
            } else if ((cord1.location === "board" && i === cord1.y && j === cord1.x) || (cord2.location === "board" && i === cord2.y && j === cord2.x)) {
              border = "lightgreen";
            }
            tableBuilder.push(`<td style="position: relative;height: 40px;width: 40px;max-width: 40px;border: solid ${border} 2px;">`);
            if (!cog.blocked) {
              tableBuilder.push(`<span style="position: absolute;top:0;left:0;">${cog.buildRate || 0}`);
              tableBuilder.push("</span>");
              tableBuilder.push(`<span style="position: absolute;top:0;right:0;">${cog.expBonus || 0}`);
              tableBuilder.push("</span>");
              tableBuilder.push(`<span style="position: absolute;bottom:0;left:0;">${cog.flaggy || 0}`);
              tableBuilder.push("</span>");
            }
            tableBuilder.push("</td>");
          }
          tableBuilder.push("</tr>");
        }
        tableBuilder.push("</table>");
        boardHtml.innerHTML = tableBuilder.join("");
        console.log("Board updated");
      }
      
      function saveGet(arr, ...indexes) {
        while(indexes.length) {
          if (arr === undefined) break;
          arr = arr[indexes.splice(0, 1)[0]];
        }
        return arr;
      }
      
      f.cloneState = (cogs, board) => {
        const c = {};
        for (let [k,v] of Object.entries(cogs)) {
          c[k] = new Cog(v);
        }
        const b = board.map((r)=>r.map((c)=>{return new Cog(c)}));
        return { cogs: c, board: b };
      }
	  
	  f.removeUselesMoves = (board, cogs) => {
	    const goal = f.getScore(board);
        const cogsToMove = Object.values(cogs)
          .filter((c) => c.key !== c.initialKey);
        // Check if move still changes something
        for (let i = 0; i < cogsToMove.length; i++) {
          const cog1 = cogsToMove[i];
          const cog1Key = cog1.key;
          const pos1 = cog1.position();
          const cog2Key = cog1.initialKey;
          const cog2 = cogs[cog2Key];
          const pos2 = cog2.position();
          if (pos1.location === "board") {
            board[pos1.y][pos1.x] = cog2;
          }
          if (pos2.location === "board") {
            board[pos2.y][pos2.x] = cog1;
          }
		  const changed = f.getScore(board);
		  if (changed.buildRate === goal.buildRate
		    && changed.flaggy === goal.flaggy
			&& changed.expBonus === goal.expBonus) {
            console.log(`Removing useless move ${cog1Key} to ${cog2Key}`);
            cog1.key = cog2Key;
            cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            cogs[cog1Key] = cog2;
			continue;
		  }
          if (pos1.location === "board") {
            board[pos1.y][pos1.x] = cog1;
          }
          if (pos2.location === "board") {
            board[pos2.y][pos2.x] = cog2;
          }
        }
	  }
	  
	  f.printOptimalSteps = (board, cogs) => {
        document.getElementById("steps").innerHTML = "";
        const cogsToMove = Object.values(cogs).map(c=>{return {...c}})
          .filter((c) => c.key !== c.initialKey);
        const interimCogs = {};
        // Remove spare movements
        for (let i = 0; i < cogsToMove.length; i++) {
          const cog = cogsToMove[i];
          if (Number.parseInt(cog.key) < 108 || Number.parseInt(cog.initialKey) < 108) continue;
          console.log(`Removing useless move ${cog.key} to ${cog.initialKey}`);
          const targetCog = cogsToMove.find(c => c.key === cog.initialKey);
          targetCog.key = cog.key;
          cogsToMove.splice(i, 1);
          i--;
        }
        // Easy switches
        for (const cog of cogsToMove) {
          const targetCog = interimCogs[cog.key];
          if (!targetCog || targetCog.initialKey !== cog.key); {
            interimCogs[cog.initialKey] = cog;
            continue;
          }
          f.printMove(board, cog, targetCog);
          delete interimCogs[cog.key];
        }
        // Multi-step movements
        let tuple;
        while (tuple = Object.entries(interimCogs)[0]) {
          const [key, cog] = tuple;
          const targetCog = interimCogs[cog.key];
          if (targetCog === cog) {
            delete interimCogs[key];
            continue;
          }
          interimCogs[key] = targetCog;
          f.printMove(board, cog, targetCog, cog.position(Number.parseInt(key)), targetCog.position(Number.parseInt(cog.key)));
          delete interimCogs[cog.key];
        }
      }
      
      document.getElementById("load").onclick = () => {
        console.log("Loading");
        const save = JSON.parse(document.getElementById("input").value);
        // Fetch Gem-Shop flaggy upgrades
        document.getElementById("flaggyShop").value = JSON.parse(save["GemItemsPurchased"])[118];
        // Fetch the list of available cogs
        const cogRaw = JSON.parse(save["CogM"]);
        const cogIcons = JSON.parse(save["CogO"]);
        const cogArray = Object.entries(cogRaw).map(([key, c]) => {
          return new Cog({
            key: key,
            initialKey: key,
            buildRate: c.a,
            isPlayer: c.b > 0,
            expGain: c.b,
            flaggy: c.c,
            expBonus: c.d,
            buildRadiusBoost: c.e,
            expRadiusBoost: c.f,
            flaggyRadiusBoost: c.g,
            boostRadius: c.h,
			icon: cogIcons[key],
            fixed: false,
            blocked: false
          });
        });
        // Get the available board
        const slots = JSON.parse(save["FlagU"]).map((n) => {
          if(n !== -11) return { fixed: true, blocked: true };
          return {};
        });
        g.cogs = {};
        for (const cog of cogArray) {
          slots[cog.key] = cog;
          g.cogs[cog.key] = cog;
        }
        g.board = [];
        for (let i = 0; i < ROWS; i++) {
          g.board.push(slots.splice(0, COLUMNS));
        }

        g.best = null;
        f.printBoard(g.board);
        document.getElementById("steps").innerHTML = "";
      };
      
      document.getElementById("solve").onclick = async () => {
	    document.getElementById("solve").innerText = "Optimizing...";
		await void 0;
        const steps = document.getElementById("steps");
        steps.innerHTML = "";
        const printMove = (board, cog1, cog2, pos1, pos2) => {
          const toAdd = document.createElement("p");
          toAdd.innerText = `Switch ${pos1.location}[${pos1.x + 1}|${pos1.y + 1}] (${cog1.buildRate || 0}:${cog1.expBonus || 0}:${cog1.flaggy || 0}) with ${pos2.location}[${pos2.x + 1}|${pos2.y + 1}] (${cog2.buildRate || 0}:${cog2.expBonus || 0}:${cog2.flaggy || 0})`;
          toAdd.onclick = () => f.printBoard(board, pos1, pos2);
          steps.appendChild(toAdd);
        }
        
        const shuffledStart = () => {
          const state = f.cloneState(g.cogs, g.board);
          state.score = f.getScore(state.board);
          state.scoreSum = f.getScoreSum(state.score);
          solutions.push(state);
          const allKeys = Object.keys(state.cogs);
          for (let i = 0; i < 500; i++) {
            const cog1Key = allKeys[Math.floor(Math.random() * allKeys.length)];
            const cog1 = state.cogs[cog1Key]
            const pos1 = cog1.position();
            const cog2Key = allKeys[Math.floor(Math.random() * allKeys.length)];
            const cog2 = state.cogs[cog2Key];
            const pos2 = cog2.position();
            if (pos1.location === "build" || pos2.location === "build") continue;
            if (pos1.location === "board") {
              state.board[pos1.y][pos1.x] = cog2;
            }
            if (pos2.location === "board") {
              state.board[pos2.y][pos2.x] = cog1;
            }
            cog1.key = cog2Key;
            state.cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            state.cogs[cog1Key] = cog2;
          }
          return state;
        }

        console.log("Starting");

        let state = f.cloneState(g.cogs, g.board);
        state.score = f.getScore(state.board);
        state.scoreSum = f.getScoreSum(state.score);
        document.getElementById("start").innerText = `Starting BuildRate: ${state.score.buildRate}, EXP: ${state.score.expBonus}, Flaggy: ${state.score.flaggy}, Sum: ${state.scoreSum}`;
        const solutions = [state];
        const allKeys = Object.keys(g.cogs);
        const startTime = Date.now();
        let counter = 0;
        console.log("Trying to optimize");
        while(Date.now() - startTime < 1000) {
          counter++;
          if (counter % 10000 === 0) {
            f.verifyBoardIntegrity(state.board);
            state = shuffledStart();
          }
          const cog1Key = allKeys[Math.floor(Math.random() * allKeys.length)];
          const cog1 = state.cogs[cog1Key]
          const pos1 = cog1.position();
          const cog2Key = allKeys[Math.floor(Math.random() * allKeys.length)];
          const cog2 = state.cogs[cog2Key];
          const pos2 = cog2.position();
          if (pos1.location !== "board" && pos2.location !== "board") continue;
          if (pos1.location === "build" || pos2.location === "build") continue;
          if (pos1.location === "board") {
            state.board[pos1.y][pos1.x] = cog2;
          }
          if (pos2.location === "board") {
            state.board[pos2.y][pos2.x] = cog1;
          }
          const scoreUpdate = f.getScore(state.board);
          const scoreSumUpdate = f.getScoreSum(scoreUpdate);
          if (scoreSumUpdate > state.scoreSum) {
            state.score = scoreUpdate;
            state.scoreSum = scoreSumUpdate;
            
            cog1.key = cog2Key;
            state.cogs[cog2Key] = cog1;
            cog2.key = cog1Key;
            state.cogs[cog1Key] = cog2;
          } else {
            if (pos1.location === "board") {
              state.board[pos1.y][pos1.x] = cog1;
            }
            if (pos2.location === "board") {
              state.board[pos2.y][pos2.x] = cog2;
            }
          }
        }
        console.log(`Tried ${counter} switches`);
        console.log(`Made ${solutions.length} different attempts with final scores: ${solutions.map(s=>s.scoreSum)}`);
        let best = solutions.reduce((a, b) => a.scoreSum >= b.scoreSum ? a : b);
        const bestIndex = solutions.indexOf(best);
        if (g.best === null || g.best.scoreSum < best.scoreSum) {
          console.log("Best solution was number", bestIndex);
          g.best = best;
        } else {
          best = g.best;
        }
        if (best.scoreSum !== f.getScoreSum(f.getScore(best.board))) {
          debugger;
        }
		for (let i = 1; i <= 5; i++) {
		  console.log("Removing usless moves", i);
		  f.removeUselesMoves(best.board, best.cogs);
		}
        f.verifyBoardIntegrity(best.board);
        if (best.scoreSum !== f.getScoreSum(f.getScore(best.board))) {
          debugger;
        }
        document.getElementById("end").innerText = `Final BuildRate: ${best.score.buildRate}, EXP: ${best.score.expBonus}, Flaggy: ${best.score.flaggy}, Sum: ${best.scoreSum}`;
        f.printOptimalSteps(best.board, best.cogs);
        f.printBoard(best.board);
	    document.getElementById("solve").innerText = "Solve";
      };
    </script>
  </body>
</html>
